name: Multi-Architecture Docker Manifest Test

on:
  workflow_dispatch:
  push:
    branches:
      - manifest  # Controlled by TARGET_BRANCH env var, change here for testing
    paths:
      - '.github/workflows/test_manifest.yml'
#multi-arch-paths-start
      - '18-3.5/bookworm/**'
      - '18-3.6/alpine3.22/**'
#multi-arch-paths-end
  pull_request:
    paths:
      - '.github/workflows/test_manifest.yml'
#multi-arch-paths-start
      - '18-3.5/bookworm/**'
      - '18-3.6/alpine3.22/**'
#multi-arch-paths-end

defaults:
  run:
    shell: bash

env:
  DOCKER_BUILDKIT: '1'
  REGISTRY: 'docker.io'
  REPO_NAME: 'imresamu'
  IMAGE_NAME: 'postgistest'
  
  # Define target branch for automated builds - easily configurable for testing
  TARGET_BRANCH: 'manifest'  # Change to 'master' for production
  
  # Define supported architectures centrally - currently active: amd64, arm64
  # To add more architectures, add them to this array and configure mappings below
  SUPPORTED_ARCHITECTURES: '["amd64", "arm64"]'
  # For additional architectures, add like: '["amd64", "arm64", "armv6", "armv7", "386", "ppc64le", "s390x", "mips64le"]'
  
  # Define architecture to runner mapping - all architectures defined for easy expansion
  ARCH_RUNNERS: '{
    "amd64": "ubuntu-22.04",
    "arm64": "ubuntu-22.04-arm",
    "armv6": "ubuntu-22.04-arm",
    "armv7": "ubuntu-22.04-arm",
    "386": "ubuntu-22.04",
    "ppc64le": "ubuntu-22.04",
    "s390x": "ubuntu-22.04",
    "mips64le": "ubuntu-22.04"
  }'
  
  # Define architecture to Docker platform mapping - all architectures defined for easy expansion
  ARCH_PLATFORMS: '{
    "amd64": "linux/amd64",
    "arm64": "linux/arm64",
    "armv6": "linux/arm/v6",
    "armv7": "linux/arm/v7",
    "386": "linux/386",
    "ppc64le": "linux/ppc64le",
    "s390x": "linux/s390x",
    "mips64le": "linux/mips64le"
  }'
  
  # Define architecture to manifest annotation mapping - all architectures defined for easy expansion
  ARCH_ANNOTATIONS: '{
    "amd64": {"os": "linux", "arch": "amd64"},
    "arm64": {"os": "linux", "arch": "arm64"},
    "armv6": {"os": "linux", "arch": "arm", "variant": "v6"},
    "armv7": {"os": "linux", "arch": "arm", "variant": "v7"},
    "386": {"os": "linux", "arch": "386"},
    "ppc64le": {"os": "linux", "arch": "ppc64le"},
    "s390x": {"os": "linux", "arch": "s390x"},
    "mips64le": {"os": "linux", "arch": "mips64le"}
  }'
  
  # Define image directories to build - automatically updated by tools/apply-ci.sh
  IMAGE_DIRECTORIES: '[
#multi-arch-include-start
    "18-3.5/bookworm",
    "18-3.6/alpine3.22"
#multi-arch-include-end
  ]'

jobs:
  prepare-matrix:
    name: "Prepare Build Matrix"
    runs-on: ubuntu-22.04
    outputs:
      matrix: ${{ steps.generate-matrix.outputs.matrix }}
      architectures: ${{ env.SUPPORTED_ARCHITECTURES }}
      image_dirs: ${{ env.IMAGE_DIRECTORIES }}
    steps:
    - name: Generate build matrix
      id: generate-matrix
      run: |
        IMAGES='${{ env.IMAGE_DIRECTORIES }}'
        ARCHITECTURES='${{ env.SUPPORTED_ARCHITECTURES }}'
        ARCH_RUNNERS='${{ env.ARCH_RUNNERS }}'
        ARCH_PLATFORMS='${{ env.ARCH_PLATFORMS }}'
        
        MATRIX_JSON='{"include":[]}'
        
        for image_dir in $(echo "$IMAGES" | jq -r '.[]'); do
          for arch in $(echo "$ARCHITECTURES" | jq -r '.[]'); do
            runner=$(echo "$ARCH_RUNNERS" | jq -r ".[\"$arch\"]")
            platform=$(echo "$ARCH_PLATFORMS" | jq -r ".[\"$arch\"]")
            
            ENTRY=$(jq -n \
              --arg image_dir "$image_dir" \
              --arg arch "$arch" \
              --arg runner "$runner" \
              --arg platform "$platform" \
              '{
                image_dir: $image_dir,
                arch_variant: $arch,
                runner: $runner,
                target: $platform
              }')
            
            MATRIX_JSON=$(echo "$MATRIX_JSON" | jq ".include += [$ENTRY]")
          done
        done
        
        echo "matrix=$MATRIX_JSON" >> $GITHUB_OUTPUT
        echo "Generated matrix:"
        echo "$MATRIX_JSON" | jq '.'

  build-images:
    name: "Build ${{ matrix.image_dir }} for ${{ matrix.arch_variant }}"
    needs: prepare-matrix
    runs-on: ${{ matrix.runner }}
    continue-on-error: false
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.prepare-matrix.outputs.matrix) }}

    steps:
    - name: Checkout source
      uses: actions/checkout@v4

    - name: Set up QEMU for cross-platform builds
      uses: docker/setup-qemu-action@v3
      with:
        platforms: all

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        install: true
        driver-opts: network=host

    - name: Install build dependencies
      run: |
        set -x
        pip3 install --upgrade pip lastversion check-jsonschema
        tools/install_manifest-tool.sh
        tools/environment_init.sh

    - name: Check Docker Hub credentials
      if: ${{ github.ref == format('refs/heads/{0}', env.TARGET_BRANCH) || github.event_name == 'workflow_dispatch' }}
      run: |
        set -x
        [[ -n "${{ secrets.DOCKERHUB_USERNAME }}" ]] || { echo "DOCKERHUB_USERNAME missing"; exit 1; }
        [[ -n "${{ secrets.DOCKERHUB_ACCESS_TOKEN }}" ]] || { echo "DOCKERHUB_ACCESS_TOKEN missing"; exit 1; }

    - name: Login to Docker Hub
      uses: docker/login-action@v3
      if: ${{ github.ref == format('refs/heads/{0}', env.TARGET_BRANCH) || github.event_name == 'workflow_dispatch' }}
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_ACCESS_TOKEN }}

    - name: Read tags from directory
      id: read-tags
      run: |
        set -x
        TAGS_FILE="${{ matrix.image_dir }}/tags"
        [[ -f "$TAGS_FILE" ]] || { echo "Tags file not found: $TAGS_FILE"; exit 1; }
        cat "$TAGS_FILE"
        TAGS=$(cat "$TAGS_FILE" | tr ' ' '\n' | sed '/^$/d' | jq -R . | jq -s . | jq -c .)
        echo "tags<<EOF" >> $GITHUB_OUTPUT
        echo "$TAGS" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Generate Docker build tags
      id: generate-tags
      run: |
        set -x
        TAGS_JSON='${{ steps.read-tags.outputs.tags }}'
        DOCKER_TAGS=""
        
        for tag in $(echo "$TAGS_JSON" | jq -r '.[]'); do
          FULL_TAG="${{ env.REGISTRY }}/${{ env.REPO_NAME }}/${{ env.IMAGE_NAME }}-${{ matrix.arch_variant }}:${tag}"
          [[ -z "$DOCKER_TAGS" ]] && DOCKER_TAGS="$FULL_TAG" || DOCKER_TAGS="$DOCKER_TAGS,$FULL_TAG"
        done

        echo "docker_tags=$DOCKER_TAGS" >> $GITHUB_OUTPUT
        echo "Generated tags:"
        echo "$DOCKER_TAGS" | tr ',' '\n'

    - name: Build Docker image
      uses: docker/build-push-action@v6
      with:
        context: ${{ matrix.image_dir }}
        file: ${{ matrix.image_dir }}/Dockerfile
        platforms: ${{ matrix.target }}
        push: false
        load: true
        tags: ${{ steps.generate-tags.outputs.docker_tags }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        provenance: false
        sbom: false
        build-args: |
          BUILDKIT_INLINE_CACHE=1

    - name: List docker images
      run: docker images

    - name: Test built image with official test suite
      run: |
        set -x
        FIRST_TAG=$(echo '${{ steps.read-tags.outputs.tags }}' | jq -r '.[0]')
        TEST_IMAGE="${{ env.REGISTRY }}/${{ env.REPO_NAME }}/${{ env.IMAGE_NAME }}-${{ matrix.arch_variant }}:${FIRST_TAG}"

        echo "Testing natively for ${{ matrix.target }}"

        git clone --depth 1 https://github.com/docker-library/official-images.git

        [[ -f "./official-images/test/run.sh" ]] || { echo "./official-images/test/run.sh not found"; exit 1; }
        [[ -f "./test/postgis-config.sh" ]] || { echo "./test/postgis-config.sh not found"; exit 1; }
        [[ -f "./official-images/test/config.sh" ]] || { echo "./official-images/test/config.sh not found"; exit 1; }

        ./official-images/test/run.sh -c ./official-images/test/config.sh -c test/postgis-config.sh "$TEST_IMAGE"

    - name: Push Docker image
      if: ${{ github.ref == format('refs/heads/{0}', env.TARGET_BRANCH) || github.event_name == 'workflow_dispatch' }}
      run: |
        set -x
        echo '${{ steps.generate-tags.outputs.docker_tags }}' | tr ',' '\n' | while read -r tag; do
          docker push "$tag"
        done

  create-manifests:
    name: "Create Multi-Arch Manifests"
    needs: [prepare-matrix, build-images]
    runs-on: ubuntu-22.04
    if: ${{ github.ref == format('refs/heads/{0}', env.TARGET_BRANCH) || github.event_name == 'workflow_dispatch' }}

    strategy:
      matrix:
        image_dir: ${{ fromJson(needs.prepare-matrix.outputs.image_dirs) }}

    steps:
    - name: Checkout source
      uses: actions/checkout@v4

    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_ACCESS_TOKEN }}

    - name: Read original tags
      id: read-original-tags
      run: |
        set -x
        TAGS_FILE="${{ matrix.image_dir }}/tags"
        [[ -f "$TAGS_FILE" ]] || { echo "Tags file not found"; exit 1; }
        cat "$TAGS_FILE"
        TAGS=$(cat "$TAGS_FILE" | tr ' ' '\n' | sed '/^$/d' | jq -R . | jq -s . | jq -c .)
        echo "tags<<EOF" >> $GITHUB_OUTPUT
        echo "$TAGS" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Create and push multi-architecture manifests
      run: |
        set -x
        TAGS_JSON='${{ steps.read-original-tags.outputs.tags }}'
        ARCHITECTURES='${{ needs.prepare-matrix.outputs.architectures }}'
        ARCH_ANNOTATIONS='${{ env.ARCH_ANNOTATIONS }}'

        for tag in $(echo "$TAGS_JSON" | jq -r '.[]'); do
          MANIFEST_TAG="${{ env.REGISTRY }}/${{ env.REPO_NAME }}/${{ env.IMAGE_NAME }}:${tag}"
          
          docker manifest rm "$MANIFEST_TAG" 2>/dev/null || true

          MANIFEST_CMD="docker manifest create --amend $MANIFEST_TAG"
          for arch in $(echo "$ARCHITECTURES" | jq -r '.[]'); do
            ARCH_TAG="${{ env.REGISTRY }}/${{ env.REPO_NAME }}/${{ env.IMAGE_NAME }}-${arch}:${tag}"
            MANIFEST_CMD="$MANIFEST_CMD $ARCH_TAG"
          done
          
          if ! eval "$MANIFEST_CMD"; then
            echo "Failed to create manifest for $MANIFEST_TAG"
            exit 1
          fi

          # Annotate each architecture with proper platform metadata
          for arch in $(echo "$ARCHITECTURES" | jq -r '.[]'); do
            ARCH_TAG="${{ env.REGISTRY }}/${{ env.REPO_NAME }}/${{ env.IMAGE_NAME }}-${arch}:${tag}"
            ANNOTATION=$(echo "$ARCH_ANNOTATIONS" | jq -r ".[\"$arch\"]")
            
            OS=$(echo "$ANNOTATION" | jq -r '.os')
            ARCH_NAME=$(echo "$ANNOTATION" | jq -r '.arch')
            VARIANT=$(echo "$ANNOTATION" | jq -r '.variant // empty')
            
            if [[ -n "$VARIANT" ]]; then
              docker manifest annotate "$MANIFEST_TAG" "$ARCH_TAG" --os "$OS" --arch "$ARCH_NAME" --variant "$VARIANT"
            else
              docker manifest annotate "$MANIFEST_TAG" "$ARCH_TAG" --os "$OS" --arch "$ARCH_NAME"
            fi
          done

          docker manifest push "$MANIFEST_TAG"
          docker manifest inspect "$MANIFEST_TAG" | jq '.manifests[] | {platform: .platform, digest: .digest}'
        done

    - name: Test multi-architecture manifests
      run: |
        set -x
        FIRST_TAG=$(echo '${{ steps.read-original-tags.outputs.tags }}' | jq -r '.[0]')
        MANIFEST_TAG="${{ env.REGISTRY }}/${{ env.REPO_NAME }}/${{ env.IMAGE_NAME }}:${FIRST_TAG}"
        
        MANIFEST_INFO=$(docker manifest inspect "$MANIFEST_TAG")
        ARCHITECTURES='${{ needs.prepare-matrix.outputs.architectures }}'
        EXPECTED_ARCHS=$(echo "$ARCHITECTURES" | jq 'length')
        ACTUAL_ARCHS=$(echo "$MANIFEST_INFO" | jq '.manifests | length')

        if [[ "$ACTUAL_ARCHS" -eq "$EXPECTED_ARCHS" ]]; then
          echo "Manifest OK: $ACTUAL_ARCHS/$EXPECTED_ARCHS architectures"
        else
          echo "Manifest ERROR: $ACTUAL_ARCHS/$EXPECTED_ARCHS architectures"
          exit 1
        fi

  summary:
    name: "Build Summary"
    needs: [prepare-matrix, build-images, create-manifests]
    runs-on: ubuntu-22.04
    if: always()

    steps:
    - name: Generate summary
      run: |
        cat >> $GITHUB_STEP_SUMMARY << 'EOF'
        ## Multi-Architecture Docker Build Summary

        ### Build Results
        EOF

        if [[ "${{ needs.build-images.result }}" == "success" ]]; then
          echo "- Individual Architecture Builds: SUCCESS" >> $GITHUB_STEP_SUMMARY
        else
          echo "- Individual Architecture Builds: FAILED" >> $GITHUB_STEP_SUMMARY
        fi

        if [[ "${{ needs.create-manifests.result }}" == "success" ]]; then
          echo "- Multi-Architecture Manifests: SUCCESS" >> $GITHUB_STEP_SUMMARY
        elif [[ "${{ needs.create-manifests.result }}" == "skipped" ]]; then
          echo "- Multi-Architecture Manifests: SKIPPED" >> $GITHUB_STEP_SUMMARY
        else
          echo "- Multi-Architecture Manifests: FAILED" >> $GITHUB_STEP_SUMMARY
        fi

        ARCHITECTURES='${{ needs.prepare-matrix.outputs.architectures }}'
        ARCH_RUNNERS='${{ env.ARCH_RUNNERS }}'
        ARCH_PLATFORMS='${{ env.ARCH_PLATFORMS }}'
        
        cat >> $GITHUB_STEP_SUMMARY << 'EOF'

        ### Architecture Support & Testing
        EOF
        
        for arch in $(echo "$ARCHITECTURES" | jq -r '.[]'); do
          runner=$(echo "$ARCH_RUNNERS" | jq -r ".[\"$arch\"]")
          platform=$(echo "$ARCH_PLATFORMS" | jq -r ".[\"$arch\"]")
          echo "- $platform: $runner (native testing)" >> $GITHUB_STEP_SUMMARY
        done

        cat >> $GITHUB_STEP_SUMMARY << 'EOF'

        ### Images Built
        EOF
        
        IMAGE_DIRS='${{ needs.prepare-matrix.outputs.image_dirs }}'
        for image_dir in $(echo "$IMAGE_DIRS" | jq -r '.[]'); do
          echo "- $image_dir" >> $GITHUB_STEP_SUMMARY
        done

        cat >> $GITHUB_STEP_SUMMARY << 'EOF'

        ### Registry Configuration
        EOF

        echo "- Registry: ${{ env.REGISTRY }}/${{ env.REPO_NAME }}/${{ env.IMAGE_NAME }}" >> $GITHUB_STEP_SUMMARY
        echo "- Push Images: ${{ (github.ref == format('refs/heads/{0}', env.TARGET_BRANCH) || github.event_name == 'workflow_dispatch') && 'Enabled' || 'Disabled' }}" >> $GITHUB_STEP_SUMMARY
        echo "- Target Branch: ${{ env.TARGET_BRANCH }}" >> $GITHUB_STEP_SUMMARY