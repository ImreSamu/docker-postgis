# yaml-language-server: $schema=https://json.schemastore.org/github-workflow.json
name: Multi-Architecture Docker Manifest Test

on:
  workflow_dispatch:
  push:
    branches:
      - manifest  # Change to 'master' for production, 'manifest' for testing
    paths:
      - '.github/workflows/test_manifest.yml'
#multi-arch-paths-start
      - '17-3.5/alpine3.22/**'
      - '18-3.5/bookworm/**'
      - '18-3.6/alpine3.22/**'
#multi-arch-paths-end
  pull_request:
    paths:
      - '.github/workflows/test_manifest.yml'
#multi-arch-paths-start
      - '17-3.5/alpine3.22/**'
      - '18-3.5/bookworm/**'
      - '18-3.6/alpine3.22/**'
#multi-arch-paths-end

defaults:
  run:
    shell: bash

env:
  DOCKER_BUILDKIT: '1'
  REGISTRY: 'docker.io'
  REPO_NAME: 'imresamu'
  IMAGE_NAME: 'postgistest'

  # Define target branch for automated builds - easily configurable for testing
  TARGET_BRANCH: 'manifest'  # Change to 'master' for production, 'manifest' for testing


  # Define supported architectures centrally 
  #    - currently active: amd64, arm64 is the best supported.
  # To add more architectures, add them to this array and configure mappings below
  SUPPORTED_ARCHITECTURES: '["amd64", "arm64", "armv6", "armv7", "386", "ppc64le", "riscv64", "s390x"]'
  # For additional architectures, add like: '["amd64", "arm64", "armv6", "armv7",
  #                                           "386", "mips64le", "ppc64le", "riscv64", "s390x"]'

  # Define architecture to runner mapping - all architectures defined for easy expansion
  ARCH_RUNNERS: '{
    "amd64":    "ubuntu-24.04",
    "arm64":    "ubuntu-24.04-arm",
    "armv6":    "ubuntu-24.04-arm",
    "armv7":    "ubuntu-24.04-arm",
    "386":      "ubuntu-24.04",
    "mips64le": "ubuntu-24.04",
    "ppc64le":  "ubuntu-24.04",
    "riscv64":  "ubuntu-24.04",
    "s390x":    "ubuntu-24.04"
  }'

  # Define architecture to Docker platform mapping - all architectures defined for easy expansion
  ARCH_PLATFORMS: '{
    "amd64":    "linux/amd64",
    "arm64":    "linux/arm64",
    "armv6":    "linux/arm/v6",
    "armv7":    "linux/arm/v7",
    "386":      "linux/386",
    "mips64le": "linux/mips64le",
    "ppc64le":  "linux/ppc64le",
    "riscv64":  "linux/riscv64",
    "s390x":    "linux/s390x"

  }'

  # Define architecture emoji mapping for better job visibility
  ARCH_EMOJIS: '{
    "amd64":    "ðŸ’»",
    "arm64":    "ðŸ’ª",
    "armv6":    "ðŸ¦¾",
    "armv7":    "ðŸ¤–",
    "386":      "ðŸ–¥ï¸",
    "mips64le": "ðŸŽ¯",
    "ppc64le":  "âš¡",
    "riscv64":  "ðŸ§©",
    "s390x":    "ðŸ¢"
  }'

  # Define regression testing mode per architecture
  # Production architectures (amd64, arm64): require - tests must pass
  # Development/experimental architectures: test - tests run but won't fail build
  ARCH_REGRESSION_MODES: '{
    "amd64":    "require",
    "arm64":    "require",
    "armv6":    "test",
    "armv7":    "test",
    "386":      "test",
    "mips64le": "test",
    "ppc64le":  "test",
    "riscv64":  "test",
    "s390x":    "test"
  }'

  # Define architecture to manifest annotation mapping - all architectures defined for easy expansion
  ARCH_ANNOTATIONS: '{
    "amd64":    {"os": "linux", "arch": "amd64"},
    "arm64":    {"os": "linux", "arch": "arm64"},
    "armv6":    {"os": "linux", "arch": "arm", "variant": "v6"},
    "armv7":    {"os": "linux", "arch": "arm", "variant": "v7"},
    "386":      {"os": "linux", "arch": "386"},
    "mips64le": {"os": "linux", "arch": "mips64le"},
    "ppc64le":  {"os": "linux", "arch": "ppc64le"},
    "riscv64":  {"os": "linux", "arch": "riscv64"},
    "s390x":    {"os": "linux", "arch": "s390x"}
  }'

  # Define image directories to build - automatically updated by tools/apply-ci.sh
  IMAGE_DIRECTORIES: '["17-3.5/alpine3.22"]'  # multi-arch-include: change here for testing

jobs:
  prepare-matrix:
    name: "ðŸŒ Prepare Matrix"
    runs-on: ubuntu-24.04
    outputs:
      matrix: ${{ steps.generate-matrix.outputs.matrix }}
      architectures: ${{ env.SUPPORTED_ARCHITECTURES }}
      image_dirs: ${{ env.IMAGE_DIRECTORIES }}
      should_push: ${{ steps.check-conditions.outputs.should_push }}
    steps:
    - name: Check push conditions
      id: check-conditions
      run: |
        if [[ "${{ github.ref }}" == "refs/heads/manifest" || "${{ github.event_name }}" == "workflow_dispatch" ]]; then  # Change to 'master' for production, 'manifest' for testing
          echo "should_push=true" >> $GITHUB_OUTPUT
        else
          echo "should_push=false" >> $GITHUB_OUTPUT
        fi
        echo "Push condition result: $(cat $GITHUB_OUTPUT | grep should_push)"

    - name: Generate build matrix
      id: generate-matrix
      run: |
        IMAGES='${{ env.IMAGE_DIRECTORIES }}'
        ARCHITECTURES='${{ env.SUPPORTED_ARCHITECTURES }}'
        ARCH_RUNNERS='${{ env.ARCH_RUNNERS }}'
        ARCH_PLATFORMS='${{ env.ARCH_PLATFORMS }}'
        ARCH_EMOJIS='${{ env.ARCH_EMOJIS }}'
        ARCH_REGRESSION_MODES='${{ env.ARCH_REGRESSION_MODES }}'

        MATRIX_JSON='{"include":[]}'

        for image_dir in $(echo "$IMAGES" | jq -r '.[]'); do
          for arch in $(echo "$ARCHITECTURES" | jq -r '.[]'); do
            runner=$(echo "$ARCH_RUNNERS" | jq -r ".[\"$arch\"]")
            platform=$(echo "$ARCH_PLATFORMS" | jq -r ".[\"$arch\"]")
            emoji=$(echo "$ARCH_EMOJIS" | jq -r ".[\"$arch\"]")
            regression_mode=$(echo "$ARCH_REGRESSION_MODES" | jq -r ".[\"$arch\"]")

            ENTRY=$(jq -n \
              --arg image_dir "$image_dir" \
              --arg arch "$arch" \
              --arg runner "$runner" \
              --arg platform "$platform" \
              --arg emoji "$emoji" \
              --arg regression_mode "$regression_mode" \
              '{
                image_dir: $image_dir,
                arch_variant: $arch,
                runner: $runner,
                target: $platform,
                arch_emoji: $emoji,
                regression_mode: $regression_mode
              }')

            MATRIX_JSON=$(echo "$MATRIX_JSON" | jq ".include += [$ENTRY]")
          done
        done

        echo "matrix<<EOF" >> $GITHUB_OUTPUT
        echo "$MATRIX_JSON" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        echo "Generated matrix:"
        echo "$MATRIX_JSON" | jq '.'

  build-images:
    name: "${{ matrix.arch_emoji }} ${{ matrix.arch_variant }} | ${{ matrix.image_dir }}"
    needs: prepare-matrix
    runs-on: ${{ matrix.runner }}
    continue-on-error: false
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.prepare-matrix.outputs.matrix) }}

    steps:
    - name: Checkout source
      uses: actions/checkout@v4

    - name: Set up QEMU for cross-platform builds
      uses: docker/setup-qemu-action@v3
      with:
        platforms: all

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        install: true
        driver-opts: network=host

    - name: Install build dependencies
      run: |
        set -x
        pip3 install --upgrade pip lastversion check-jsonschema
        tools/install_manifest-tool.sh
        tools/environment_init.sh

    - name: Check Docker Hub credentials
      if: ${{ needs.prepare-matrix.outputs.should_push == 'true' }}
      run: |
        set -x
        [[ -n "${{ secrets.DOCKERHUB_USERNAME }}" ]] || { echo "DOCKERHUB_USERNAME missing"; exit 1; }
        [[ -n "${{ secrets.DOCKERHUB_ACCESS_TOKEN }}" ]] || { echo "DOCKERHUB_ACCESS_TOKEN missing"; exit 1; }

    - name: Login to Docker Hub
      uses: docker/login-action@v3
      if: ${{ needs.prepare-matrix.outputs.should_push == 'true' }}
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_ACCESS_TOKEN }}

    - name: Read tags from directory
      id: read-tags
      run: |
        set -x
        TAGS_FILE="${{ matrix.image_dir }}/tags"
        [[ -f "$TAGS_FILE" ]] || { echo "Tags file not found: $TAGS_FILE"; exit 1; }
        cat "$TAGS_FILE"
        TAGS=$(cat "$TAGS_FILE" | tr ' ' '\n' | sed '/^$/d' | jq -R . | jq -s . | jq -c .)
        echo "tags<<EOF" >> $GITHUB_OUTPUT
        echo "$TAGS" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Generate Docker build tags
      id: generate-tags
      run: |
        set -x
        TAGS_JSON='${{ steps.read-tags.outputs.tags }}'
        DOCKER_TAGS=""

        for tag in $(echo "$TAGS_JSON" | jq -r '.[]'); do
          FULL_TAG="${{ env.REGISTRY }}/${{ env.REPO_NAME }}/${{ env.IMAGE_NAME }}-${{ matrix.arch_variant }}:${tag}"
          [[ -z "$DOCKER_TAGS" ]] && DOCKER_TAGS="$FULL_TAG" || DOCKER_TAGS="$DOCKER_TAGS,$FULL_TAG"
        done

        echo "docker_tags=$DOCKER_TAGS" >> $GITHUB_OUTPUT
        echo "Generated tags:"
        echo "$DOCKER_TAGS" | tr ',' '\n'

    - name: Build Docker image
      uses: docker/build-push-action@v6
      with:
        context: ${{ matrix.image_dir }}
        file: ${{ matrix.image_dir }}/Dockerfile
        platforms: ${{ matrix.target }}
        push: false
        load: true
        tags: ${{ steps.generate-tags.outputs.docker_tags }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        provenance: false
        sbom: false
        build-args: |
          BUILDKIT_INLINE_CACHE=1
          PGIS1_REGRESSION_MODE=${{ matrix.regression_mode }}

    - name: List docker images
      run: docker images

    - name: Test built image with official test suite
      run: |
        set -x
        FIRST_TAG=$(echo '${{ steps.read-tags.outputs.tags }}' | jq -r '.[0]')
        TEST_IMAGE="${{ env.REGISTRY }}/${{ env.REPO_NAME }}/${{ env.IMAGE_NAME }}-${{ matrix.arch_variant }}:${FIRST_TAG}"

        echo "Testing natively for ${{ matrix.target }}"

        git clone --depth 1 https://github.com/docker-library/official-images.git

        [[ -f "./official-images/test/run.sh" ]] || { echo "./official-images/test/run.sh not found"; exit 1; }
        [[ -f "./test/postgis-config.sh" ]] || { echo "./test/postgis-config.sh not found"; exit 1; }
        [[ -f "./official-images/test/config.sh" ]] || { echo "./official-images/test/config.sh not found"; exit 1; }

        ./official-images/test/run.sh -c ./official-images/test/config.sh -c test/postgis-config.sh "$TEST_IMAGE"

    - name: Push Docker image
      if: ${{ needs.prepare-matrix.outputs.should_push == 'true' }}
      run: |
        set -x
        echo '${{ steps.generate-tags.outputs.docker_tags }}' | tr ',' '\n' | while read -r tag; do
          docker push "$tag"
        done

  create-manifests:
    name: "ðŸ“¦ ${{ matrix.image_dir }} | manifest"
    needs: [prepare-matrix, build-images]
    runs-on: ubuntu-24.04
    if: ${{ needs.prepare-matrix.outputs.should_push == 'true' }}

    strategy:
      matrix:
        image_dir: ${{ fromJson(needs.prepare-matrix.outputs.image_dirs) }}

    steps:
    - name: Checkout source
      uses: actions/checkout@v4

    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_ACCESS_TOKEN }}

    - name: Read original tags
      id: read-original-tags
      run: |
        set -x
        TAGS_FILE="${{ matrix.image_dir }}/tags"
        [[ -f "$TAGS_FILE" ]] || { echo "Tags file not found"; exit 1; }
        cat "$TAGS_FILE"
        TAGS=$(cat "$TAGS_FILE" | tr ' ' '\n' | sed '/^$/d' | jq -R . | jq -s . | jq -c .)
        echo "tags<<EOF" >> $GITHUB_OUTPUT
        echo "$TAGS" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Create and push multi-architecture manifests
      run: |
        set -x
        TAGS_JSON='${{ steps.read-original-tags.outputs.tags }}'
        ARCHITECTURES='${{ needs.prepare-matrix.outputs.architectures }}'
        ARCH_ANNOTATIONS='${{ env.ARCH_ANNOTATIONS }}'

        for tag in $(echo "$TAGS_JSON" | jq -r '.[]'); do
          MANIFEST_TAG="${{ env.REGISTRY }}/${{ env.REPO_NAME }}/${{ env.IMAGE_NAME }}:${tag}"

          docker manifest rm "$MANIFEST_TAG" 2>/dev/null || true

          MANIFEST_CMD="docker manifest create --amend $MANIFEST_TAG"
          for arch in $(echo "$ARCHITECTURES" | jq -r '.[]'); do
            ARCH_TAG="${{ env.REGISTRY }}/${{ env.REPO_NAME }}/${{ env.IMAGE_NAME }}-${arch}:${tag}"
            MANIFEST_CMD="$MANIFEST_CMD $ARCH_TAG"
          done

          if ! eval "$MANIFEST_CMD"; then
            echo "Failed to create manifest for $MANIFEST_TAG"
            exit 1
          fi

          # Annotate each architecture with proper platform metadata
          for arch in $(echo "$ARCHITECTURES" | jq -r '.[]'); do
            ARCH_TAG="${{ env.REGISTRY }}/${{ env.REPO_NAME }}/${{ env.IMAGE_NAME }}-${arch}:${tag}"
            ANNOTATION=$(echo "$ARCH_ANNOTATIONS" | jq -r ".[\"$arch\"]")

            OS=$(echo "$ANNOTATION" | jq -r '.os')
            ARCH_NAME=$(echo "$ANNOTATION" | jq -r '.arch')
            VARIANT=$(echo "$ANNOTATION" | jq -r '.variant // empty')

            if [[ -n "$VARIANT" ]]; then
              docker manifest annotate "$MANIFEST_TAG" "$ARCH_TAG" --os "$OS" --arch "$ARCH_NAME" --variant "$VARIANT"
            else
              docker manifest annotate "$MANIFEST_TAG" "$ARCH_TAG" --os "$OS" --arch "$ARCH_NAME"
            fi
          done

          docker manifest push "$MANIFEST_TAG"
          docker manifest inspect "$MANIFEST_TAG" | jq '.manifests[] | {platform: .platform, digest: .digest}'
        done

    - name: Test multi-architecture manifests
      run: |
        set -x
        FIRST_TAG=$(echo '${{ steps.read-original-tags.outputs.tags }}' | jq -r '.[0]')
        MANIFEST_TAG="${{ env.REGISTRY }}/${{ env.REPO_NAME }}/${{ env.IMAGE_NAME }}:${FIRST_TAG}"

        MANIFEST_INFO=$(docker manifest inspect "$MANIFEST_TAG")
        ARCHITECTURES='${{ needs.prepare-matrix.outputs.architectures }}'
        EXPECTED_ARCHS=$(echo "$ARCHITECTURES" | jq 'length')
        ACTUAL_ARCHS=$(echo "$MANIFEST_INFO" | jq '.manifests | length')

        if [[ "$ACTUAL_ARCHS" -eq "$EXPECTED_ARCHS" ]]; then
          echo "Manifest OK: $ACTUAL_ARCHS/$EXPECTED_ARCHS architectures"
        else
          echo "Manifest ERROR: $ACTUAL_ARCHS/$EXPECTED_ARCHS architectures"
          exit 1
        fi

  summary:
    name: "ðŸ“Š Build Summary"
    needs: [prepare-matrix, build-images, create-manifests]
    runs-on: ubuntu-24.04
    if: always()

    steps:
    - name: Generate summary
      run: |
        cat >> $GITHUB_STEP_SUMMARY << 'EOF'
        ## Multi-Architecture Docker Build Summary

        ### Build Results
        EOF

        if [[ "${{ needs.build-images.result }}" == "success" ]]; then
          echo "- Individual Architecture Builds: SUCCESS" >> $GITHUB_STEP_SUMMARY
        else
          echo "- Individual Architecture Builds: FAILED" >> $GITHUB_STEP_SUMMARY
        fi

        if [[ "${{ needs.create-manifests.result }}" == "success" ]]; then
          echo "- Multi-Architecture Manifests: SUCCESS" >> $GITHUB_STEP_SUMMARY
        elif [[ "${{ needs.create-manifests.result }}" == "skipped" ]]; then
          echo "- Multi-Architecture Manifests: SKIPPED" >> $GITHUB_STEP_SUMMARY
        else
          echo "- Multi-Architecture Manifests: FAILED" >> $GITHUB_STEP_SUMMARY
        fi

        ARCHITECTURES='${{ needs.prepare-matrix.outputs.architectures }}'
        ARCH_RUNNERS='${{ env.ARCH_RUNNERS }}'
        ARCH_PLATFORMS='${{ env.ARCH_PLATFORMS }}'

        cat >> $GITHUB_STEP_SUMMARY << 'EOF'

        ### Architecture Support & Testing
        EOF

        for arch in $(echo "$ARCHITECTURES" | jq -r '.[]'); do
          runner=$(echo "$ARCH_RUNNERS" | jq -r ".[\"$arch\"]")
          platform=$(echo "$ARCH_PLATFORMS" | jq -r ".[\"$arch\"]")
          echo "- $platform: $runner (native testing)" >> $GITHUB_STEP_SUMMARY
        done

        cat >> $GITHUB_STEP_SUMMARY << 'EOF'

        ### Images Built
        EOF

        IMAGE_DIRS='${{ needs.prepare-matrix.outputs.image_dirs }}'
        for image_dir in $(echo "$IMAGE_DIRS" | jq -r '.[]'); do
          echo "- $image_dir" >> $GITHUB_STEP_SUMMARY
        done

        cat >> $GITHUB_STEP_SUMMARY << 'EOF'

        ### Registry Configuration
        EOF

        echo "- Registry: ${{ env.REGISTRY }}/${{ env.REPO_NAME }}/${{ env.IMAGE_NAME }}" >> $GITHUB_STEP_SUMMARY
        echo "- Push Images: ${{ needs.prepare-matrix.outputs.should_push == 'true' && 'Enabled' || 'Disabled' }}" >> $GITHUB_STEP_SUMMARY
        echo "- Target Branch: ${{ env.TARGET_BRANCH }}" >> $GITHUB_STEP_SUMMARY