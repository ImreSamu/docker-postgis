# yaml-language-server: $schema=https://json.schemastore.org/github-workflow.json
name: Multi-Architecture Docker Manifest Build Template

# Concurrency removed - let groups run in parallel with explicit dependencies
# Resource protection handled by max-parallel limits within each template call

on:
  workflow_call:
    inputs:
      workflow_name:
        description: 'Name of the workflow (e.g., Alpine, Debian)'
        required: true
        type: string
      supported_architectures:
        description: 'JSON array of supported architectures'
        required: true
        type: string
      image_directories:
        description: 'JSON array of image directories to build'
        required: true
        type: string
      target_branch:
        description: 'Target branch for automated builds'
        required: false
        type: string
        default: 'manifest'
      registry:
        description: 'Docker registry'
        required: false
        type: string
        default: 'docker.io'
      repo_name:
        description: 'Repository name'
        required: false
        type: string
        default: 'imresamu'
      image_name:
        description: 'Base image name'
        required: false
        type: string
        default: 'postgistest'
      schedule_parallel:
        description: 'Max parallel builds for scheduled runs'
        required: false
        type: number
        default: 8
      manual_parallel:
        description: 'Max parallel builds for manual (workflow_dispatch) runs'
        required: false
        type: number
        default: 6
      push_pr_parallel:
        description: 'Max parallel builds for push/PR runs'
        required: false
        type: number
        default: 4
    secrets:
      DOCKERHUB_USERNAME:
        required: true
      DOCKERHUB_ACCESS_TOKEN:
        required: true

defaults:
  run:
    shell: bash

env:
  DOCKER_BUILDKIT: '1'
  REGISTRY: ${{ inputs.registry }}
  REPO_NAME: ${{ inputs.repo_name }}
  IMAGE_NAME: ${{ inputs.image_name }}
  TARGET_BRANCH: ${{ inputs.target_branch }}

  # Define supported architectures from input
  SUPPORTED_ARCHITECTURES: ${{ inputs.supported_architectures }}

  # Define architecture to runner mapping - all architectures defined for easy expansion
  ARCH_RUNNERS: '{
    "amd64":    "ubuntu-24.04",
    "arm64":    "ubuntu-24.04-arm",
    "armv6":    "ubuntu-24.04-arm",
    "armv7":    "ubuntu-24.04-arm",
    "386":      "ubuntu-24.04",
    "mips64le": "ubuntu-24.04",
    "ppc64le":  "ubuntu-24.04",
    "riscv64":  "ubuntu-24.04",
    "s390x":    "ubuntu-24.04"
  }'

  # Define architecture to Docker platform mapping - all architectures defined for easy expansion
  ARCH_PLATFORMS: '{
    "amd64":    "linux/amd64",
    "arm64":    "linux/arm64",
    "armv6":    "linux/arm/v6",
    "armv7":    "linux/arm/v7",
    "386":      "linux/386",
    "mips64le": "linux/mips64le",
    "ppc64le":  "linux/ppc64le",
    "riscv64":  "linux/riscv64",
    "s390x":    "linux/s390x"

  }'

  # Define architecture emoji mapping for better job visibility
  ARCH_EMOJIS: '{
    "amd64":    "ðŸ’»",
    "arm64":    "ðŸ’ª",
    "armv6":    "ðŸ¦¾",
    "armv7":    "ðŸ¤–",
    "386":      "ðŸ–¥ï¸",
    "mips64le": "ðŸŽ¯",
    "ppc64le":  "âš¡",
    "riscv64":  "ðŸ§©",
    "s390x":    "ðŸ¢"
  }'

  # Define regression testing mode per architecture
  # Production architectures (amd64, arm64): require - tests must pass
  # Development/experimental architectures: test - tests run but won't fail build
  # JIT-incompatible architectures: test_nojit - tests with JIT disabled
  # Most problematic architectures: skip - no regression tests at all
  ARCH_REGRESSION_MODES: '{
    "amd64":    "require",
    "arm64":    "require",
    "armv6":    "test_nojit",
    "armv7":    "test_nojit",
    "386":      "test",
    "mips64le": "skip",
    "ppc64le":  "skip",
    "riscv64":  "test_nojit",
    "s390x":    "skip"
  }'

  # Define regression mode emoji mapping
  REGRESSION_MODE_EMOJIS: '{
    "skip":       "ðŸ’¨",
    "test":       "ðŸ”",
    "require":    "ðŸ”’",
    "test_nojit": "ðŸ”ðŸ¢"
  }'

  # Define build type emoji mapping (native vs QEMU)
  BUILD_TYPE_EMOJIS: '{
    "native": "âš¡",
    "qemu":   "ðŸ”„"
  }'

  # Define native build detection (runner architecture matches target architecture)
  ARCH_NATIVE_BUILDS: '{
    "amd64":    "native",
    "arm64":    "native",
    "armv6":    "qemu",
    "armv7":    "qemu",
    "386":      "qemu",
    "mips64le": "qemu",
    "ppc64le":  "qemu",
    "riscv64":  "qemu",
    "s390x":    "qemu"
  }'

  # Define optimization flags per architecture (following PostGIS CI script style)
  # Production architectures (amd64, arm64): -O3 with compiler warnings for maximum performance
  # Experimental architectures: -O1 with compiler warnings for build stability
  # Note: -Werror removed to prevent build failures from PostGIS warnings
  ARCH_OPTIMIZATION_FLAGS: '{
    "amd64":    "-O3 -Wall -fno-omit-frame-pointer",
    "arm64":    "-O3 -Wall -fno-omit-frame-pointer",
    "armv6":    "-O1 -Wall -fno-omit-frame-pointer",
    "armv7":    "-O1 -Wall -fno-omit-frame-pointer",
    "386":      "-O1 -Wall -fno-omit-frame-pointer",
    "mips64le": "-O1 -Wall -fno-omit-frame-pointer",
    "ppc64le":  "-O1 -Wall -fno-omit-frame-pointer",
    "riscv64":  "-O1 -Wall -fno-omit-frame-pointer",
    "s390x":    "-O1 -Wall -fno-omit-frame-pointer"
  }'

  # Define LTO (Link Time Optimization) per architecture
  # Production architectures: LTO enabled for maximum performance
  # Experimental architectures: LTO disabled for build stability
  ARCH_LTO_FLAGS: '{
    "amd64":    "--enable-lto",
    "arm64":    "--enable-lto",
    "armv6":    "",
    "armv7":    "",
    "386":      "",
    "mips64le": "",
    "ppc64le":  "",
    "riscv64":  "",
    "s390x":    ""
  }'

  # Define image directories from input
  IMAGE_DIRECTORIES: ${{ inputs.image_directories }}

jobs:
  prepare-matrix:
    name: "ðŸŒ Prepare Matrix | ${{ inputs.workflow_name }}"
    runs-on: ubuntu-24.04
    outputs:
      matrix: ${{ steps.generate-matrix.outputs.matrix }}
      architectures: ${{ env.SUPPORTED_ARCHITECTURES }}
      image_dirs: ${{ env.IMAGE_DIRECTORIES }}
      should_push: ${{ steps.check-conditions.outputs.should_push }}
    steps:
    - name: Check push conditions
      id: check-conditions
      run: |
        if [[ "${{ github.ref }}" == "refs/heads/${{ env.TARGET_BRANCH }}" || "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          echo "should_push=true" >> $GITHUB_OUTPUT
        else
          echo "should_push=false" >> $GITHUB_OUTPUT
        fi
        echo "Push condition result: $(cat $GITHUB_OUTPUT | grep should_push)"

    - name: Generate build matrix
      id: generate-matrix
      run: |
        IMAGES='${{ env.IMAGE_DIRECTORIES }}'
        ARCHITECTURES='${{ env.SUPPORTED_ARCHITECTURES }}'
        ARCH_RUNNERS='${{ env.ARCH_RUNNERS }}'
        ARCH_PLATFORMS='${{ env.ARCH_PLATFORMS }}'
        ARCH_EMOJIS='${{ env.ARCH_EMOJIS }}'
        ARCH_REGRESSION_MODES='${{ env.ARCH_REGRESSION_MODES }}'
        REGRESSION_MODE_EMOJIS='${{ env.REGRESSION_MODE_EMOJIS }}'
        BUILD_TYPE_EMOJIS='${{ env.BUILD_TYPE_EMOJIS }}'
        ARCH_NATIVE_BUILDS='${{ env.ARCH_NATIVE_BUILDS }}'
        ARCH_OPTIMIZATION_FLAGS='${{ env.ARCH_OPTIMIZATION_FLAGS }}'
        ARCH_LTO_FLAGS='${{ env.ARCH_LTO_FLAGS }}'

        MATRIX_JSON='{"include":[]}'

        for image_dir in $(echo "$IMAGES" | jq -r '.[]'); do
          for arch in $(echo "$ARCHITECTURES" | jq -r '.[]'); do
            runner=$(echo "$ARCH_RUNNERS" | jq -r ".[\"$arch\"]")
            platform=$(echo "$ARCH_PLATFORMS" | jq -r ".[\"$arch\"]")
            emoji=$(echo "$ARCH_EMOJIS" | jq -r ".[\"$arch\"]")
            regression_mode=$(echo "$ARCH_REGRESSION_MODES" | jq -r ".[\"$arch\"]")
            regression_emoji=$(echo "$REGRESSION_MODE_EMOJIS" | jq -r ".[\"$regression_mode\"]")
            build_type=$(echo "$ARCH_NATIVE_BUILDS" | jq -r ".[\"$arch\"]")
            build_type_emoji=$(echo "$BUILD_TYPE_EMOJIS" | jq -r ".[\"$build_type\"]")
            optimization_flags=$(echo "$ARCH_OPTIMIZATION_FLAGS" | jq -r ".[\"$arch\"]")
            lto_flags=$(echo "$ARCH_LTO_FLAGS" | jq -r ".[\"$arch\"]")

            ENTRY=$(jq -n \
              --arg image_dir "$image_dir" \
              --arg arch "$arch" \
              --arg runner "$runner" \
              --arg platform "$platform" \
              --arg emoji "$emoji" \
              --arg regression_mode "$regression_mode" \
              --arg regression_emoji "$regression_emoji" \
              --arg build_type_emoji "$build_type_emoji" \
              --arg optimization_flags "$optimization_flags" \
              --arg lto_flags "$lto_flags" \
              '{
                image_dir: $image_dir,
                arch_variant: $arch,
                runner: $runner,
                target: $platform,
                arch_emoji: $emoji,
                regression_mode: $regression_mode,
                regression_emoji: $regression_emoji,
                build_type_emoji: $build_type_emoji,
                optimization_flags: $optimization_flags,
                lto_flags: $lto_flags
              }')

            MATRIX_JSON=$(echo "$MATRIX_JSON" | jq ".include += [$ENTRY]")
          done
        done

        echo "matrix<<EOF" >> $GITHUB_OUTPUT
        echo "$MATRIX_JSON" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        echo "Generated matrix:"
        echo "$MATRIX_JSON" | jq '.'

  build-images:
    name: "${{ matrix.arch_emoji }}${{ matrix.arch_variant }}|${{ matrix.regression_emoji }}${{ matrix.image_dir }}${{ matrix.build_type_emoji }}"
    needs: prepare-matrix
    runs-on: ${{ matrix.runner }}
    continue-on-error: false
    strategy:
      fail-fast: true
      max-parallel: ${{ github.event_name == 'schedule' && inputs.schedule_parallel || github.event_name == 'workflow_dispatch' && inputs.manual_parallel || inputs.push_pr_parallel }}
      matrix: ${{ fromJson(needs.prepare-matrix.outputs.matrix) }}

    steps:
    - name: Checkout source
      uses: actions/checkout@v4

    - name: Set up QEMU for cross-platform builds
      if: ${{ matrix.build_type == 'qemu' }}
      uses: docker/setup-qemu-action@v3
      with:
        platforms: all

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        install: true
        driver-opts: network=host
        platforms: ${{ matrix.target }}

    - name: Install build dependencies
      run: |
        set -x
        pip3 install --upgrade pip lastversion check-jsonschema
        tools/environment_init.sh

    - name: Check Docker Hub credentials
      if: ${{ needs.prepare-matrix.outputs.should_push == 'true' }}
      run: |
        set -x
        [[ -n "${{ secrets.DOCKERHUB_USERNAME }}" ]] || { echo "DOCKERHUB_USERNAME missing"; exit 1; }
        [[ -n "${{ secrets.DOCKERHUB_ACCESS_TOKEN }}" ]] || { echo "DOCKERHUB_ACCESS_TOKEN missing"; exit 1; }

    - name: Login to Docker Hub
      uses: docker/login-action@v3
      if: ${{ needs.prepare-matrix.outputs.should_push == 'true' }}
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_ACCESS_TOKEN }}

    - name: Read tags from directory
      id: read-tags
      run: |
        set -x
        TAGS_FILE="${{ matrix.image_dir }}/tags"
        [[ -f "$TAGS_FILE" ]] || { echo "Tags file not found: $TAGS_FILE"; exit 1; }
        cat "$TAGS_FILE"
        TAGS=$(cat "$TAGS_FILE" | tr ' ' '\n' | sed '/^$/d' | jq -R . | jq -s . | jq -c .)
        echo "tags<<EOF" >> $GITHUB_OUTPUT
        echo "$TAGS" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Generate Docker build tags
      id: generate-tags
      run: |
        set -x
        TAGS_JSON='${{ steps.read-tags.outputs.tags }}'
        
        # Generate short tags for building (avoid Docker tag length issues)
        SHORT_TAGS=""
        FINAL_TAGS=""
        
        for tag in $(echo "$TAGS_JSON" | jq -r '.[]'); do
          SHORT_TAG=$(echo "$tag" | cut -d'-' -f1)
          SHORT_IMAGE="${{ env.IMAGE_NAME }}-${{ matrix.arch_variant }}:${SHORT_TAG}"
          FULL_TAG="${{ env.REGISTRY }}/${{ env.REPO_NAME }}/${{ env.IMAGE_NAME }}-${{ matrix.arch_variant }}:${tag}"
          
          [[ -z "$SHORT_TAGS" ]] && SHORT_TAGS="$SHORT_IMAGE" || SHORT_TAGS="$SHORT_TAGS,$SHORT_IMAGE"
          [[ -z "$FINAL_TAGS" ]] && FINAL_TAGS="$FULL_TAG" || FINAL_TAGS="$FINAL_TAGS,$FULL_TAG"
        done

        echo "short_tags=$SHORT_TAGS" >> $GITHUB_OUTPUT
        echo "final_tags=$FINAL_TAGS" >> $GITHUB_OUTPUT
        echo "Generated short build tags:"
        echo "$SHORT_TAGS" | tr ',' '\n'
        echo "Generated final push tags:"
        echo "$FINAL_TAGS" | tr ',' '\n'

    - name: Build Docker image
      uses: docker/build-push-action@v6
      with:
        context: ${{ matrix.image_dir }}
        file: ${{ matrix.image_dir }}/Dockerfile
        platforms: ${{ matrix.target }}
        push: false
        load: true
        tags: ${{ steps.generate-tags.outputs.short_tags }}
        cache-from: type=gha,scope=${{ matrix.arch_variant }}-${{ matrix.image_dir }}
        cache-to: type=gha,mode=max,scope=${{ matrix.arch_variant }}-${{ matrix.image_dir }},compression=zstd
        provenance: false
        sbom: false
        build-args: |
          BUILDKIT_INLINE_CACHE=1
          PGIS1_REGRESSION_MODE=${{ matrix.regression_mode }}
          PGIS1_OPTIMIZATION_FLAGS="${{ matrix.optimization_flags }}"
          PGIS1_LTO_FLAGS="${{ matrix.lto_flags }}"
          REGISTRY=${{ env.REGISTRY }}
          REPO_NAME=${{ env.REPO_NAME }}
          IMAGE_NAME=${{ env.IMAGE_NAME }}-${{ matrix.arch_variant }}

    - name: List docker images
      run: docker images

    - name: Test built image with official test suite
      run: |
        set -x
        FIRST_TAG=$(echo '${{ steps.read-tags.outputs.tags }}' | jq -r '.[0]')
        SHORT_TAG=$(echo "$FIRST_TAG" | cut -d'-' -f1)
        SHORT_TEST_IMAGE="${{ env.IMAGE_NAME }}-${{ matrix.arch_variant }}:${SHORT_TAG}"

        echo "Testing for ${{ matrix.target }} (build type: ${{ matrix.build_type_emoji }})"
        echo "Testing short image: $SHORT_TEST_IMAGE"

        git clone --depth 1 https://github.com/docker-library/official-images.git

        [[ -f "./official-images/test/run.sh" ]] || { echo "./official-images/test/run.sh not found"; exit 1; }
        [[ -f "./test/postgis-config.sh" ]] || { echo "./test/postgis-config.sh not found"; exit 1; }
        [[ -f "./official-images/test/config.sh" ]] || { echo "./official-images/test/config.sh not found"; exit 1; }

        # Set platform for all builds to ensure correct image resolution
        echo "Setting platform for ${{ matrix.target }} (build type: ${{ matrix.build_type_emoji }})"
        export DOCKER_DEFAULT_PLATFORM="${{ matrix.target }}"
        echo "Set DOCKER_DEFAULT_PLATFORM=$DOCKER_DEFAULT_PLATFORM"
        
        # Quick platform test for all architectures
        docker run --rm --platform ${{ matrix.target }} "$SHORT_TEST_IMAGE" echo "Platform test successful" || {
          echo "Platform test failed, but continuing with official tests"
        }

        # Create test configuration for short image name
        export REGISTRY=""
        export REPO_NAME=""
        export IMAGE_NAME="${{ env.IMAGE_NAME }}-${{ matrix.arch_variant }}"
        
        # Run official test suite with short image name
        ./official-images/test/run.sh -c ./official-images/test/config.sh -c test/postgis-config.sh "$SHORT_TEST_IMAGE"

    - name: Tag and push Docker images
      if: ${{ needs.prepare-matrix.outputs.should_push == 'true' }}
      run: |
        set -x
        # Get short and final tags
        SHORT_TAGS='${{ steps.generate-tags.outputs.short_tags }}'
        FINAL_TAGS='${{ steps.generate-tags.outputs.final_tags }}'
        
        # Convert comma-separated lists to arrays
        IFS=',' read -ra SHORT_ARRAY <<< "$SHORT_TAGS"
        IFS=',' read -ra FINAL_ARRAY <<< "$FINAL_TAGS"
        
        # Tag each short image with final names and push
        for i in "${!SHORT_ARRAY[@]}"; do
          SHORT_TAG="${SHORT_ARRAY[i]}"
          FINAL_TAG="${FINAL_ARRAY[i]}"
          
          echo "Tagging $SHORT_TAG as $FINAL_TAG"
          docker tag "$SHORT_TAG" "$FINAL_TAG"
          
          echo "Pushing $FINAL_TAG"
          docker push "$FINAL_TAG"
        done

  create-manifests:
    name: "ðŸ“¦ Create manifests | ${{ inputs.workflow_name }}"
    needs: [prepare-matrix, build-images]
    runs-on: ubuntu-24.04
    if: ${{ needs.prepare-matrix.outputs.should_push == 'true' }}

    steps:
    - name: Checkout source
      uses: actions/checkout@v4

    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_ACCESS_TOKEN }}


    - name: Create and push multi-architecture manifests
      run: |
        set -x
        IMAGE_DIRS='${{ needs.prepare-matrix.outputs.image_dirs }}'
        ARCHITECTURES='${{ needs.prepare-matrix.outputs.architectures }}'

        for image_dir in $(echo "$IMAGE_DIRS" | jq -r '.[]'); do
          TAGS_FILE="$image_dir/tags"
          [[ -f "$TAGS_FILE" ]] || { echo "Tags file not found: $TAGS_FILE"; exit 1; }

          TAGS=$(cat "$TAGS_FILE" | tr ' ' '\n' | sed '/^$/d' | jq -R . | jq -s . | jq -c .)

          for tag in $(echo "$TAGS" | jq -r '.[]'); do
            MANIFEST_TAG="${{ env.REGISTRY }}/${{ env.REPO_NAME }}/${{ env.IMAGE_NAME }}:${tag}"

            SOURCE_TAGS=""
            for arch in $(echo "$ARCHITECTURES" | jq -r '.[]'); do
              ARCH_TAG="${{ env.REGISTRY }}/${{ env.REPO_NAME }}/${{ env.IMAGE_NAME }}-${arch}:${tag}"
              [[ -z "$SOURCE_TAGS" ]] && SOURCE_TAGS="$ARCH_TAG" || SOURCE_TAGS="$SOURCE_TAGS $ARCH_TAG"
            done

            docker buildx imagetools create -t "$MANIFEST_TAG" $SOURCE_TAGS
            docker buildx imagetools inspect "$MANIFEST_TAG"
          done
        done

    - name: Test manifests
      run: |
        set -x
        IMAGE_DIRS='${{ needs.prepare-matrix.outputs.image_dirs }}'
        ARCHITECTURES='${{ needs.prepare-matrix.outputs.architectures }}'
        EXPECTED_ARCHS=$(echo "$ARCHITECTURES" | jq 'length')

        for image_dir in $(echo "$IMAGE_DIRS" | jq -r '.[]'); do
          FIRST_TAG=$(cat "$image_dir/tags" | tr ' ' '\n' | sed '/^$/d' | head -n1)
          MANIFEST_TAG="${{ env.REGISTRY }}/${{ env.REPO_NAME }}/${{ env.IMAGE_NAME }}:${FIRST_TAG}"

          echo "Checking manifest: $MANIFEST_TAG"
          docker buildx imagetools inspect "$MANIFEST_TAG"
        done
