# yaml-language-server: $schema=https://json.schemastore.org/github-workflow.json
name: Multi-Architecture Docker Manifest Build Template

# Ensure only one instance of this template runs at a time across all workflows
concurrency:
  group: docker-manifest-build-template
  cancel-in-progress: false

on:
  workflow_call:
    inputs:
      workflow_name:
        description: 'Name of the workflow (e.g., Alpine, Debian)'
        required: true
        type: string
      supported_architectures:
        description: 'JSON array of supported architectures'
        required: true
        type: string
      image_directories:
        description: 'JSON array of image directories to build'
        required: true
        type: string
      target_branch:
        description: 'Target branch for automated builds'
        required: false
        type: string
        default: 'manifest'
      registry:
        description: 'Docker registry'
        required: false
        type: string
        default: 'docker.io'
      repo_name:
        description: 'Repository name'
        required: false
        type: string
        default: 'imresamu'
      image_name:
        description: 'Base image name'
        required: false
        type: string
        default: 'postgistest'
    secrets:
      DOCKERHUB_USERNAME:
        required: true
      DOCKERHUB_ACCESS_TOKEN:
        required: true

defaults:
  run:
    shell: bash

env:
  DOCKER_BUILDKIT: '1'
  REGISTRY: ${{ inputs.registry }}
  REPO_NAME: ${{ inputs.repo_name }}
  IMAGE_NAME: ${{ inputs.image_name }}
  TARGET_BRANCH: ${{ inputs.target_branch }}

  # Define supported architectures from input
  SUPPORTED_ARCHITECTURES: ${{ inputs.supported_architectures }}

  # Define architecture to runner mapping - all architectures defined for easy expansion
  ARCH_RUNNERS: '{
    "amd64":    "ubuntu-24.04",
    "arm64":    "ubuntu-24.04-arm",
    "armv6":    "ubuntu-24.04-arm",
    "armv7":    "ubuntu-24.04-arm",
    "386":      "ubuntu-24.04",
    "mips64le": "ubuntu-24.04",
    "ppc64le":  "ubuntu-24.04",
    "riscv64":  "ubuntu-24.04",
    "s390x":    "ubuntu-24.04"
  }'

  # Define architecture to Docker platform mapping - all architectures defined for easy expansion
  ARCH_PLATFORMS: '{
    "amd64":    "linux/amd64",
    "arm64":    "linux/arm64",
    "armv6":    "linux/arm/v6",
    "armv7":    "linux/arm/v7",
    "386":      "linux/386",
    "mips64le": "linux/mips64le",
    "ppc64le":  "linux/ppc64le",
    "riscv64":  "linux/riscv64",
    "s390x":    "linux/s390x"

  }'

  # Define architecture emoji mapping for better job visibility
  ARCH_EMOJIS: '{
    "amd64":    "ðŸ’»",
    "arm64":    "ðŸ’ª",
    "armv6":    "ðŸ¦¾",
    "armv7":    "ðŸ¤–",
    "386":      "ðŸ–¥ï¸",
    "mips64le": "ðŸŽ¯",
    "ppc64le":  "âš¡",
    "riscv64":  "ðŸ§©",
    "s390x":    "ðŸ¢"
  }'

  # Define regression testing mode per architecture
  # Production architectures (amd64, arm64): require - tests must pass
  # Development/experimental architectures: test - tests run but won't fail build
  # JIT-incompatible architectures: test_nojit - tests with JIT disabled
  # Most problematic architectures: skip - no regression tests at all
  ARCH_REGRESSION_MODES: '{
    "amd64":    "require",
    "arm64":    "require",
    "armv6":    "test",
    "armv7":    "test",
    "386":      "test",
    "mips64le": "skip",
    "ppc64le":  "skip",
    "riscv64":  "test_nojit",
    "s390x":    "skip"
  }'

  # Define regression mode emoji mapping  
  REGRESSION_MODE_EMOJIS: '{
    "skip":       "ðŸ’¨",
    "test":       "ðŸ”", 
    "require":    "ðŸ”’",
    "test_nojit": "ðŸ”ðŸ¢"
  }'

  # Define build type emoji mapping (native vs QEMU)
  BUILD_TYPE_EMOJIS: '{
    "native": "âš¡",
    "qemu":   "ðŸ”„"
  }'

  # Define native build detection (runner architecture matches target architecture)
  ARCH_NATIVE_BUILDS: '{
    "amd64":    "native",
    "arm64":    "native",
    "armv6":    "qemu",
    "armv7":    "qemu", 
    "386":      "qemu",
    "mips64le": "qemu",
    "ppc64le":  "qemu",
    "riscv64":  "qemu",
    "s390x":    "qemu"
  }'

  # Define optimization flags per architecture (following PostGIS CI script style)
  # Production architectures (amd64, arm64): -O3 with compiler warnings for maximum performance
  # Experimental architectures: -O1 with compiler warnings for build stability
  # Note: -Werror removed to prevent build failures from PostGIS warnings
  ARCH_OPTIMIZATION_FLAGS: '{
    "amd64":    "-O3 -Wall -fno-omit-frame-pointer",
    "arm64":    "-O3 -Wall -fno-omit-frame-pointer",
    "armv6":    "-O1 -Wall -fno-omit-frame-pointer",
    "armv7":    "-O1 -Wall -fno-omit-frame-pointer",
    "386":      "-O1 -Wall -fno-omit-frame-pointer",
    "mips64le": "-O1 -Wall -fno-omit-frame-pointer",
    "ppc64le":  "-O1 -Wall -fno-omit-frame-pointer",
    "riscv64":  "-O1 -Wall -fno-omit-frame-pointer",
    "s390x":    "-O1 -Wall -fno-omit-frame-pointer"
  }'

  # Define LTO (Link Time Optimization) per architecture
  # Production architectures: LTO enabled for maximum performance
  # Experimental architectures: LTO disabled for build stability
  ARCH_LTO_FLAGS: '{
    "amd64":    "--enable-lto",
    "arm64":    "--enable-lto",
    "armv6":    "",
    "armv7":    "",
    "386":      "",
    "mips64le": "",
    "ppc64le":  "",
    "riscv64":  "",
    "s390x":    ""
  }'

  # Define architecture to manifest annotation mapping - all architectures defined for easy expansion
  ARCH_ANNOTATIONS: '{
    "amd64":    {"os": "linux", "arch": "amd64"},
    "arm64":    {"os": "linux", "arch": "arm64"},
    "armv6":    {"os": "linux", "arch": "arm", "variant": "v6"},
    "armv7":    {"os": "linux", "arch": "arm", "variant": "v7"},
    "386":      {"os": "linux", "arch": "386"},
    "mips64le": {"os": "linux", "arch": "mips64le"},
    "ppc64le":  {"os": "linux", "arch": "ppc64le"},
    "riscv64":  {"os": "linux", "arch": "riscv64"},
    "s390x":    {"os": "linux", "arch": "s390x"}
  }'

  # Define image directories from input
  IMAGE_DIRECTORIES: ${{ inputs.image_directories }}

jobs:
  prepare-matrix:
    name: "ðŸŒ Prepare Matrix"
    runs-on: ubuntu-24.04
    outputs:
      matrix: ${{ steps.generate-matrix.outputs.matrix }}
      architectures: ${{ env.SUPPORTED_ARCHITECTURES }}
      image_dirs: ${{ env.IMAGE_DIRECTORIES }}
      should_push: ${{ steps.check-conditions.outputs.should_push }}
    steps:
    - name: Check push conditions
      id: check-conditions
      run: |
        if [[ "${{ github.ref }}" == "refs/heads/${{ env.TARGET_BRANCH }}" || "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          echo "should_push=true" >> $GITHUB_OUTPUT
        else
          echo "should_push=false" >> $GITHUB_OUTPUT
        fi
        echo "Push condition result: $(cat $GITHUB_OUTPUT | grep should_push)"

    - name: Generate build matrix
      id: generate-matrix
      run: |
        IMAGES='${{ env.IMAGE_DIRECTORIES }}'
        ARCHITECTURES='${{ env.SUPPORTED_ARCHITECTURES }}'
        ARCH_RUNNERS='${{ env.ARCH_RUNNERS }}'
        ARCH_PLATFORMS='${{ env.ARCH_PLATFORMS }}'
        ARCH_EMOJIS='${{ env.ARCH_EMOJIS }}'
        ARCH_REGRESSION_MODES='${{ env.ARCH_REGRESSION_MODES }}'
        REGRESSION_MODE_EMOJIS='${{ env.REGRESSION_MODE_EMOJIS }}'
        BUILD_TYPE_EMOJIS='${{ env.BUILD_TYPE_EMOJIS }}'
        ARCH_NATIVE_BUILDS='${{ env.ARCH_NATIVE_BUILDS }}'
        ARCH_OPTIMIZATION_FLAGS='${{ env.ARCH_OPTIMIZATION_FLAGS }}'
        ARCH_LTO_FLAGS='${{ env.ARCH_LTO_FLAGS }}'

        MATRIX_JSON='{"include":[]}'

        for image_dir in $(echo "$IMAGES" | jq -r '.[]'); do
          for arch in $(echo "$ARCHITECTURES" | jq -r '.[]'); do
            runner=$(echo "$ARCH_RUNNERS" | jq -r ".[\"$arch\"]")
            platform=$(echo "$ARCH_PLATFORMS" | jq -r ".[\"$arch\"]")
            emoji=$(echo "$ARCH_EMOJIS" | jq -r ".[\"$arch\"]")
            regression_mode=$(echo "$ARCH_REGRESSION_MODES" | jq -r ".[\"$arch\"]")
            regression_emoji=$(echo "$REGRESSION_MODE_EMOJIS" | jq -r ".[\"$regression_mode\"]")
            build_type=$(echo "$ARCH_NATIVE_BUILDS" | jq -r ".[\"$arch\"]")
            build_type_emoji=$(echo "$BUILD_TYPE_EMOJIS" | jq -r ".[\"$build_type\"]")
            optimization_flags=$(echo "$ARCH_OPTIMIZATION_FLAGS" | jq -r ".[\"$arch\"]")
            lto_flags=$(echo "$ARCH_LTO_FLAGS" | jq -r ".[\"$arch\"]")

            ENTRY=$(jq -n \
              --arg image_dir "$image_dir" \
              --arg arch "$arch" \
              --arg runner "$runner" \
              --arg platform "$platform" \
              --arg emoji "$emoji" \
              --arg regression_mode "$regression_mode" \
              --arg regression_emoji "$regression_emoji" \
              --arg build_type_emoji "$build_type_emoji" \
              --arg optimization_flags "$optimization_flags" \
              --arg lto_flags "$lto_flags" \
              '{
                image_dir: $image_dir,
                arch_variant: $arch,
                runner: $runner,
                target: $platform,
                arch_emoji: $emoji,
                regression_mode: $regression_mode,
                regression_emoji: $regression_emoji,
                build_type_emoji: $build_type_emoji,
                optimization_flags: $optimization_flags,
                lto_flags: $lto_flags
              }')

            MATRIX_JSON=$(echo "$MATRIX_JSON" | jq ".include += [$ENTRY]")
          done
        done

        echo "matrix<<EOF" >> $GITHUB_OUTPUT
        echo "$MATRIX_JSON" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        echo "Generated matrix:"
        echo "$MATRIX_JSON" | jq '.'

  build-images:
    name: "${{ matrix.arch_emoji }}${{ matrix.arch_variant }}|${{ matrix.regression_emoji }}${{ matrix.image_dir }}${{ matrix.build_type_emoji }}"
    needs: prepare-matrix
    runs-on: ${{ matrix.runner }}
    continue-on-error: false
    strategy:
      fail-fast: false
      max-parallel: 10
      matrix: ${{ fromJson(needs.prepare-matrix.outputs.matrix) }}

    steps:
    - name: Checkout source
      uses: actions/checkout@v4

    - name: Set up QEMU for cross-platform builds
      uses: docker/setup-qemu-action@v3
      with:
        platforms: all

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        install: true
        driver-opts: network=host

    - name: Install build dependencies
      run: |
        set -x
        pip3 install --upgrade pip lastversion check-jsonschema
        tools/install_manifest-tool.sh
        tools/environment_init.sh

    - name: Check Docker Hub credentials
      if: ${{ needs.prepare-matrix.outputs.should_push == 'true' }}
      run: |
        set -x
        [[ -n "${{ secrets.DOCKERHUB_USERNAME }}" ]] || { echo "DOCKERHUB_USERNAME missing"; exit 1; }
        [[ -n "${{ secrets.DOCKERHUB_ACCESS_TOKEN }}" ]] || { echo "DOCKERHUB_ACCESS_TOKEN missing"; exit 1; }

    - name: Login to Docker Hub
      uses: docker/login-action@v3
      if: ${{ needs.prepare-matrix.outputs.should_push == 'true' }}
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_ACCESS_TOKEN }}

    - name: Read tags from directory
      id: read-tags
      run: |
        set -x
        TAGS_FILE="${{ matrix.image_dir }}/tags"
        [[ -f "$TAGS_FILE" ]] || { echo "Tags file not found: $TAGS_FILE"; exit 1; }
        cat "$TAGS_FILE"
        TAGS=$(cat "$TAGS_FILE" | tr ' ' '\n' | sed '/^$/d' | jq -R . | jq -s . | jq -c .)
        echo "tags<<EOF" >> $GITHUB_OUTPUT
        echo "$TAGS" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Generate Docker build tags
      id: generate-tags
      run: |
        set -x
        TAGS_JSON='${{ steps.read-tags.outputs.tags }}'
        DOCKER_TAGS=""

        for tag in $(echo "$TAGS_JSON" | jq -r '.[]'); do
          FULL_TAG="${{ env.REGISTRY }}/${{ env.REPO_NAME }}/${{ env.IMAGE_NAME }}-${{ matrix.arch_variant }}:${tag}"
          [[ -z "$DOCKER_TAGS" ]] && DOCKER_TAGS="$FULL_TAG" || DOCKER_TAGS="$DOCKER_TAGS,$FULL_TAG"
        done

        echo "docker_tags=$DOCKER_TAGS" >> $GITHUB_OUTPUT
        echo "Generated tags:"
        echo "$DOCKER_TAGS" | tr ',' '\n'

    - name: Build Docker image
      uses: docker/build-push-action@v6
      with:
        context: ${{ matrix.image_dir }}
        file: ${{ matrix.image_dir }}/Dockerfile
        platforms: ${{ matrix.target }}
        push: false
        load: true
        tags: ${{ steps.generate-tags.outputs.docker_tags }}
        cache-from: type=gha,scope=${{ matrix.arch_variant }}-${{ matrix.image_dir }}
        cache-to: type=gha,mode=max,scope=${{ matrix.arch_variant }}-${{ matrix.image_dir }},compression=zstd
        provenance: false
        sbom: false
        build-args: |
          BUILDKIT_INLINE_CACHE=1
          PGIS1_REGRESSION_MODE=${{ matrix.regression_mode }}
          PGIS1_OPTIMIZATION_FLAGS=${{ matrix.optimization_flags }}
          PGIS1_LTO_FLAGS=${{ matrix.lto_flags }}

    - name: List docker images
      run: docker images

    - name: Test built image with official test suite
      run: |
        set -x
        FIRST_TAG=$(echo '${{ steps.read-tags.outputs.tags }}' | jq -r '.[0]')
        TEST_IMAGE="${{ env.REGISTRY }}/${{ env.REPO_NAME }}/${{ env.IMAGE_NAME }}-${{ matrix.arch_variant }}:${FIRST_TAG}"

        echo "Testing natively for ${{ matrix.target }}"

        git clone --depth 1 https://github.com/docker-library/official-images.git

        [[ -f "./official-images/test/run.sh" ]] || { echo "./official-images/test/run.sh not found"; exit 1; }
        [[ -f "./test/postgis-config.sh" ]] || { echo "./test/postgis-config.sh not found"; exit 1; }
        [[ -f "./official-images/test/config.sh" ]] || { echo "./official-images/test/config.sh not found"; exit 1; }

        ./official-images/test/run.sh -c ./official-images/test/config.sh -c test/postgis-config.sh "$TEST_IMAGE"

    - name: Push Docker image
      if: ${{ needs.prepare-matrix.outputs.should_push == 'true' }}
      run: |
        set -x
        echo '${{ steps.generate-tags.outputs.docker_tags }}' | tr ',' '\n' | while read -r tag; do
          docker push "$tag"
        done

  create-manifests:
    name: "ðŸ“¦ ${{ matrix.image_dir }} | manifest"
    needs: [prepare-matrix, build-images]
    runs-on: ubuntu-24.04
    if: ${{ needs.prepare-matrix.outputs.should_push == 'true' }}

    strategy:
      max-parallel: 1
      matrix:
        image_dir: ${{ fromJson(needs.prepare-matrix.outputs.image_dirs) }}

    steps:
    - name: Checkout source
      uses: actions/checkout@v4

    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_ACCESS_TOKEN }}

    - name: Read original tags
      id: read-original-tags
      run: |
        set -x
        TAGS_FILE="${{ matrix.image_dir }}/tags"
        [[ -f "$TAGS_FILE" ]] || { echo "Tags file not found"; exit 1; }
        cat "$TAGS_FILE"
        TAGS=$(cat "$TAGS_FILE" | tr ' ' '\n' | sed '/^$/d' | jq -R . | jq -s . | jq -c .)
        echo "tags<<EOF" >> $GITHUB_OUTPUT
        echo "$TAGS" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Create and push multi-architecture manifests
      run: |
        set -x
        TAGS_JSON='${{ steps.read-original-tags.outputs.tags }}'
        ARCHITECTURES='${{ needs.prepare-matrix.outputs.architectures }}'
        ARCH_ANNOTATIONS='${{ env.ARCH_ANNOTATIONS }}'

        for tag in $(echo "$TAGS_JSON" | jq -r '.[]'); do
          MANIFEST_TAG="${{ env.REGISTRY }}/${{ env.REPO_NAME }}/${{ env.IMAGE_NAME }}:${tag}"

          docker manifest rm "$MANIFEST_TAG" 2>/dev/null || true

          MANIFEST_CMD="docker manifest create --amend $MANIFEST_TAG"
          for arch in $(echo "$ARCHITECTURES" | jq -r '.[]'); do
            ARCH_TAG="${{ env.REGISTRY }}/${{ env.REPO_NAME }}/${{ env.IMAGE_NAME }}-${arch}:${tag}"
            MANIFEST_CMD="$MANIFEST_CMD $ARCH_TAG"
          done

          if ! eval "$MANIFEST_CMD"; then
            echo "Failed to create manifest for $MANIFEST_TAG"
            exit 1
          fi

          # Annotate each architecture with proper platform metadata
          for arch in $(echo "$ARCHITECTURES" | jq -r '.[]'); do
            ARCH_TAG="${{ env.REGISTRY }}/${{ env.REPO_NAME }}/${{ env.IMAGE_NAME }}-${arch}:${tag}"
            ANNOTATION=$(echo "$ARCH_ANNOTATIONS" | jq -r ".[\"$arch\"]")

            OS=$(echo "$ANNOTATION" | jq -r '.os')
            ARCH_NAME=$(echo "$ANNOTATION" | jq -r '.arch')
            VARIANT=$(echo "$ANNOTATION" | jq -r '.variant // empty')

            if [[ -n "$VARIANT" ]]; then
              docker manifest annotate "$MANIFEST_TAG" "$ARCH_TAG" --os "$OS" --arch "$ARCH_NAME" --variant "$VARIANT"
            else
              docker manifest annotate "$MANIFEST_TAG" "$ARCH_TAG" --os "$OS" --arch "$ARCH_NAME"
            fi
          done

          docker manifest push "$MANIFEST_TAG"
          docker manifest inspect "$MANIFEST_TAG" | jq '.manifests[] | {platform: .platform, digest: .digest}'
        done

    - name: Test multi-architecture manifests
      run: |
        set -x
        FIRST_TAG=$(echo '${{ steps.read-original-tags.outputs.tags }}' | jq -r '.[0]')
        MANIFEST_TAG="${{ env.REGISTRY }}/${{ env.REPO_NAME }}/${{ env.IMAGE_NAME }}:${FIRST_TAG}"

        MANIFEST_INFO=$(docker manifest inspect "$MANIFEST_TAG")
        ARCHITECTURES='${{ needs.prepare-matrix.outputs.architectures }}'
        EXPECTED_ARCHS=$(echo "$ARCHITECTURES" | jq 'length')
        ACTUAL_ARCHS=$(echo "$MANIFEST_INFO" | jq '.manifests | length')

        if [[ "$ACTUAL_ARCHS" -eq "$EXPECTED_ARCHS" ]]; then
          echo "Manifest OK: $ACTUAL_ARCHS/$EXPECTED_ARCHS architectures"
        else
          echo "Manifest ERROR: $ACTUAL_ARCHS/$EXPECTED_ARCHS architectures"
          exit 1
        fi

  summary:
    name: "ðŸ“Š Build Summary"
    needs: [prepare-matrix, build-images, create-manifests]
    runs-on: ubuntu-24.04
    if: always()

    steps:
    - name: Generate summary
      env:
        GH_TOKEN: ${{ github.token }}
      run: |
        cat >> $GITHUB_STEP_SUMMARY << 'EOF'
        ## Multi-Architecture Docker Build Summary (${{ inputs.workflow_name }})
        EOF

        echo "### Build Results & Log Analysis" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "| Image Directory | Architecture | Test Mode | Build Type | Errors | Warnings | Result | Log Details |" >> $GITHUB_STEP_SUMMARY
        echo "|-----------------|--------------|-----------|------------|--------|----------|--------|-------------|" >> $GITHUB_STEP_SUMMARY


    - name: Analyze complete job results
      if: always()
      env:
        GH_TOKEN: ${{ github.token }}
      run: |
        echo "Analyzing complete job logs for detailed error and warning counts..."
        
        # Job log analysis data will be written to the combined table above
        
        # Get job details for this workflow run
        JOBS_JSON=$(gh api repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/jobs --jq '.jobs[]')
        
        # Process each build job
        echo "$JOBS_JSON" | jq -c 'select(.name | contains("build-images") or test("ðŸ’»|ðŸ’ª|ðŸ¦¾|ðŸ¤–|ðŸ–¥ï¸|ðŸŽ¯|âš¡|ðŸ§©|ðŸ¢"))' | while read -r job; do
          JOB_ID=$(echo "$job" | jq -r '.id')
          JOB_NAME=$(echo "$job" | jq -r '.name')
          JOB_STATUS=$(echo "$job" | jq -r '.status')
          JOB_CONCLUSION=$(echo "$job" | jq -r '.conclusion // "in_progress"')
          
          # Extract architecture and image directory from job name
          # Job name format: {arch_emoji}{arch_name}|{regression_emoji}{image_dir}{build_type_emoji}
          ARCH=""
          IMAGE_DIR=""
          
          if [[ "$JOB_NAME" =~ ðŸ’» ]]; then ARCH="amd64"
          elif [[ "$JOB_NAME" =~ ðŸ’ª ]]; then ARCH="arm64"
          elif [[ "$JOB_NAME" =~ ðŸ¦¾ ]]; then ARCH="armv6"
          elif [[ "$JOB_NAME" =~ ðŸ¤– ]]; then ARCH="armv7"
          elif [[ "$JOB_NAME" =~ ðŸ–¥ï¸ ]]; then ARCH="386"
          elif [[ "$JOB_NAME" =~ ðŸŽ¯ ]]; then ARCH="mips64le"
          elif [[ "$JOB_NAME" =~ âš¡ ]]; then ARCH="ppc64le"
          elif [[ "$JOB_NAME" =~ ðŸ§© ]]; then ARCH="riscv64"
          elif [[ "$JOB_NAME" =~ ðŸ¢ ]]; then ARCH="s390x"
          else ARCH="unknown"
          fi
          
          # Extract image directory from job name (after | and before final emoji)
          if [[ "$JOB_NAME" =~ \|[ðŸ”’ðŸ”ðŸ’¨ðŸ¢]+([^âš¡ðŸ”„]+)[âš¡ðŸ”„] ]]; then
            IMAGE_DIR="${BASH_REMATCH[1]}"
          elif [[ "$JOB_NAME" =~ \|[ðŸ”’ðŸ”ðŸ’¨ðŸ¢]+([^âš¡ðŸ”„]+)$ ]]; then
            IMAGE_DIR="${BASH_REMATCH[1]}"
          else
            # Fallback: try to extract any path-like pattern from job name
            if [[ "$JOB_NAME" =~ ([0-9]+-[0-9]\.[0-9]/[a-zA-Z0-9\.]+) ]]; then
              IMAGE_DIR="${BASH_REMATCH[1]}"
            else
              IMAGE_DIR="unknown"
            fi
          fi

          if [[ "$JOB_STATUS" == "completed" ]]; then
            echo "Analyzing job $JOB_ID ($ARCH)..."
            
            # Get job logs
            JOB_LOG=$(gh api repos/${{ github.repository }}/actions/jobs/$JOB_ID/logs 2>/dev/null || echo "Log unavailable")
            
            # Count errors and warnings in the logs
            ERROR_COUNT=0
            WARNING_COUNT=0
            TEST_STATUS="ðŸ”â“ Unknown"
            
            if [[ "$JOB_LOG" != "Log unavailable" ]] && [[ ${#JOB_LOG} -gt 100 ]]; then
              # Count critical error patterns (excluding compiler flags, echo statements, and other false positives)  
              ERROR_COUNT=$(echo "$JOB_LOG" | grep -vE "(\-Werror|\-Wall|\-Wno\-|gcc.*\-W|echo.*ERROR|RUN set.*ERROR)" | grep -ciE "(FATAL|CRITICAL|make:.*Error|ERROR.*failed|FAILED.*error|Build failed|compilation.*failed|configure.*failed|Connection.*failed|server.*terminated abnormally)" 2>/dev/null || echo "0")
              ERROR_COUNT=$(echo "$ERROR_COUNT" | tr -d '\n\r' | xargs)
              
              # Count warning patterns (excluding documentation/build tools and informational messages)
              WARNING_COUNT=$(echo "$JOB_LOG" | grep -vE "(hint:|initdb:.*warning.*trust|configure:.*WARNING.*not installed|configure:.*WARNING.*cannot be built|configure:.*WARNING.*stylesheets)" | grep -ciE "(WARNING|WARN(?!ING.*disabled)|deprecated|caution)" 2>/dev/null || echo "0")
              WARNING_COUNT=$(echo "$WARNING_COUNT" | tr -d '\n\r' | xargs)
              
              # Determine test result based on log content and job conclusion
              if [[ "$JOB_CONCLUSION" == "success" ]]; then
                # Check for regression test failure patterns first
                if echo "$JOB_LOG" | grep -qi "make:.*Error.*check-regress\|psql.*error.*connection.*lost\|server.*terminated abnormally"; then
                  TEST_STATUS="ðŸ”ðŸ’¥ Tests Crashed (Non-blocking)"
                elif echo "$JOB_LOG" | grep -qi "REGRESSION_TESTS_FAILED_EXIT_CODE"; then
                  # Extract the exit code to understand severity
                  EXIT_CODE=$(echo "$JOB_LOG" | grep -o "REGRESSION_TESTS_FAILED_EXIT_CODE_[0-9]*" | tail -1 | grep -o "[0-9]*$" || echo "unknown")
                  TEST_STATUS="ðŸ”âŒ Tests Failed (Exit: $EXIT_CODE, Non-blocking)"
                elif echo "$JOB_LOG" | grep -qi "regression.*pass\|All tests passed\|CHECK passed\|Regression test completed.*mode.*non-blocking"; then
                  # Check if it's a no-jit test mode
                  if echo "$JOB_LOG" | grep -qi "test_nojit.*mode\|JIT disabled"; then
                    TEST_STATUS="ðŸ”ðŸ¢âœ… Tests Passed (No-JIT)"
                  else
                    TEST_STATUS="ðŸ”âœ… Tests Passed"
                  fi
                else
                  TEST_STATUS="ðŸ”âœ… Build Success"
                fi
              elif [[ "$JOB_CONCLUSION" == "failure" ]]; then
                if echo "$JOB_LOG" | grep -qi "regression.*fail\|test.*fail\|REGRESSION_TESTS_FAILED_EXIT_CODE"; then
                  TEST_STATUS="ðŸ”âŒ Tests Error"
                else
                  TEST_STATUS="ðŸ”âŒ Build Error"
                fi
              else
                TEST_STATUS="ðŸ”â¸ï¸ $JOB_CONCLUSION"
              fi
            else
              # Log unavailable or too short (likely from cache)
              ERROR_COUNT="N/A"
              WARNING_COUNT="N/A" 
              TEST_STATUS="ðŸ”ðŸ’¾ Cache/No Log Analysis"
            fi
            
            # Get test mode and build type for this architecture
            ARCH_REGRESSION_MODES='${{ env.ARCH_REGRESSION_MODES }}'
            REGRESSION_MODE_EMOJIS='${{ env.REGRESSION_MODE_EMOJIS }}'
            ARCH_NATIVE_BUILDS='${{ env.ARCH_NATIVE_BUILDS }}'
            BUILD_TYPE_EMOJIS='${{ env.BUILD_TYPE_EMOJIS }}'
            
            regression_mode=$(echo "$ARCH_REGRESSION_MODES" | jq -r ".[\"$ARCH\"]")
            regression_emoji=$(echo "$REGRESSION_MODE_EMOJIS" | jq -r ".[\"$regression_mode\"]")
            build_type=$(echo "$ARCH_NATIVE_BUILDS" | jq -r ".[\"$ARCH\"]")
            build_type_emoji=$(echo "$BUILD_TYPE_EMOJIS" | jq -r ".[\"$build_type\"]")
            
            TEST_MODE="$regression_emoji $regression_mode"
            BUILD_TYPE_DISPLAY="$build_type_emoji $build_type"
            
            # Format log details link
            LOG_DETAILS="[View Logs](/${{ github.repository }}/actions/runs/${{ github.run_id }}/job/$JOB_ID)"
            
            echo "| $IMAGE_DIR | $ARCH | $TEST_MODE | $BUILD_TYPE_DISPLAY | $ERROR_COUNT | $WARNING_COUNT | $TEST_STATUS | $LOG_DETAILS |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| $IMAGE_DIR | $ARCH | - | - | - | - | ðŸ”â¸ï¸ $JOB_STATUS | - |" >> $GITHUB_STEP_SUMMARY
          fi
        done

        cat >> $GITHUB_STEP_SUMMARY << 'EOF'

        ### Registry Configuration
        EOF

        echo "- Registry: ${{ env.REGISTRY }}/${{ env.REPO_NAME }}/${{ env.IMAGE_NAME }}" >> $GITHUB_STEP_SUMMARY
        echo "- Push Images: ${{ needs.prepare-matrix.outputs.should_push == 'true' && 'Enabled' || 'Disabled' }}" >> $GITHUB_STEP_SUMMARY
        echo "- Target Branch: ${{ env.TARGET_BRANCH }}" >> $GITHUB_STEP_SUMMARY
        echo "- Workflow: ${{ inputs.workflow_name }}" >> $GITHUB_STEP_SUMMARY
        echo "- Architectures: $(echo '${{ env.SUPPORTED_ARCHITECTURES }}' | jq -r 'join(", ")')" >> $GITHUB_STEP_SUMMARY
        echo "- Image Directories: $(echo '${{ env.IMAGE_DIRECTORIES }}' | jq -r 'join(", ")')" >> $GITHUB_STEP_SUMMARY